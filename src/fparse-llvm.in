#!/usr/bin/env bash

# Copyright (C) 2024, ParaTools, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


set -o errexit
set -o nounset
set -o pipefail
#set -o verbose
#set -o xtrace

readonly _VERSION=@SALT_VERSION_MAJOR@.@SALT_VERSION_MINOR@
readonly _FORTRAN_CONFIG_FILE_BUILD=@CMAKE_SOURCE_DIR@/config_files/tau_config.yaml
readonly _FORTRAN_CONFIG_FILE_INSTALL=@SALT_CONFIGFILES_INSTALL_DIR@/tau_config.yaml
readonly _INSTALL_DEST=@CMAKE_INSTALL_PREFIX@

# get the absolute path of this script
readonly _SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# Check if the script is being run from the install directory
if [[ -f "${_SCRIPT_DIR}/$0" && "${_SCRIPT_DIR}" == ${_INSTALL_DEST}* ]]; then
    FORTRAN_CONFIG_FILE="${_FORTRAN_CONFIG_FILE_INSTALL}"
else
    FORTRAN_CONFIG_FILE="${_FORTRAN_CONFIG_FILE_BUILD}"
fi

# Add a help/usage message function
function usage {
    echo "Usage: $0 [-h] [-o output_file] [-show] input_file [args]"
    echo "         -h: print this help message and exit"    
    echo "         --tau_output=output_file: specify the output file name"
    echo "         -show: print the command line without running it"
    echo "          input_file: the Fortran source file to parse and instrument"
    echo "          args: additional arguments to pass to the flang compiler (include flags etc.)"

}

if [[ $# -eq 0 ]]; then
    usage
    exit 1
fi

# Loop over the arguments and check for the output file -o flag and it's argument
# If found, set the output file name to the argument following the -o flag and remove the -o flag and argument from the argument list
# If not found, set the output file name to the first argument with a .inst extension
#echo "Passed command line arguments: $*"

args=()
expecting_output_file=false
forward_remaining_args=false
show=false
for arg in "$@"; do
    #echo "working on arg: $arg"
    if [[ $forward_remaining_args == true ]]; then
        args+=("${@}")
        #echo "args remaining: $*"
        break
    fi
    if [[ $arg == -h ]]; then
        usage
        exit 0
    elif $expecting_output_file; then
        output_file="$arg"
        expecting_output_file=false
        shift || true
        #echo "args remaining: $*"
    elif [[ $arg == -o || $arg == --tau_output ]]; then
        shift
        expecting_output_file=true
        #echo "args remaining: $*"
    elif [[ $arg == -o* ]]; then
        output_file="${arg#-o}"
        shift || true
        #echo "args remaining: $*"
    elif [[ $arg == --tau_output=* ]]; then
        output_file="${arg#--tau_output=}"
        shift || true
        #echo "args remaining: $*"
    elif [[ $arg == *.[Ff]90 || $arg == *.[Ff] || $arg == *.[Ff]03 ]]; then
        input_file="$arg"
        shift || true
        #echo "args remaining: $*"
    elif [[ $arg == -show ]]; then
        show=true
        shift || true
        #echo "args remaining: $*"
    elif [[ $arg == --config_file=* ]]; then
        FORTRAN_CONFIG_FILE="${arg#--config_file=}"
        shift || true
        #echo "args remaining: $*"
    elif [[ $arg == -- ]]; then
        shift
        forward_remaining_args=true
        #echo "args remaining: $*"
    elif [[ -n ${arg:-} ]]; then
        args+=("${arg}")
        shift || true
        #echo "args remaining: $*"
    fi
done

#echo "args: \"${args[*]}\""
# print the argument list
if [[ -z "${input_file:-}" ]]; then
    input_file="${args[0]}"
    args=("${args[@]:1}")
fi

echo "input file: ${input_file:-\"<None given>\" }"

# If no output file is given, emit the output file in the current working directory
if [[ -z "${output_file:-}" ]]; then
    if [[ ${input_file} == *.* ]]; then
      file_ext=".${input_file##*.}"
    else
        file_ext=""
    fi
    if [[ "${input_file}" == */* ]]; then
        output_file="${input_file%.*}.inst${file_ext//f/F}"
        output_file="$(pwd)/${output_file##*/}"
    else
        output_file="$(pwd)/${input_file%.*}.inst${file_ext//f/F}"
    fi
    
fi
echo "output file: ${output_file:-\"<None given>\" }"
echo "Remaining Arguments: ${args[*]}"

# This script invokes an LLVM flang frontend plugin to parse and instrument Fortran code
cmd=(flang-new
    -fc1
    -load ./libsalt-flang-plugin.so
    -plugin salt-instrument
    "${input_file}" 
    -o "${output_file}"
    "${args[@]}")
if $show; then
    echo "SALT_FORTRAN_CONFIG_FILE=\"${FORTRAN_CONFIG_FILE}\""
    echo "cmd: ${cmd[*]}"
else
    echo "SALT_FORTRAN_CONFIG_FILE=\"${FORTRAN_CONFIG_FILE}\""
    echo "Running: ${cmd[*]}"
    SALT_FORTRAN_CONFIG_FILE="${FORTRAN_CONFIG_FILE}" "${cmd[@]}"
    exit $?
fi
